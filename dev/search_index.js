var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ArDCA","category":"page"},{"location":"#ArDCA","page":"Home","title":"ArDCA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Autoreressive model learning for protein inference.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Learn model from multiple sequence alignment\nSample from the model ","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Protein families are given in form of multiple sequence alignments (MSA) D = (a^m_i i = 1dotsLm = 1dotsM) of M proteins of aligned length L. The entries a^m_i equal either one of the standard 20 amino acids, or the alignment gap . In total, we have q = 21 possible different symbols in D. The aim of unsupervised generative modeling is to earn a statistical model P(a1dotsa_L) of (aligned) full-length sequences, which faithfully reflects the variability found in D: sequences belonging to the protein family of interest should have comparably high probabilities, unrelated sequences very small probabilities. Here we propose a computationally efficient approach based on autoregressive models. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start from the exact decomposition:","category":"page"},{"location":"","page":"Home","title":"Home","text":"P(a_1dotsa_L) = P(a_1) cdot P(a_2a_1) cdot dots cdot P(a_La_1dotsa_L-1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we use the following parametrization:","category":"page"},{"location":"","page":"Home","title":"Home","text":"P(a_i  a_1dotsa_i-1) = fracexp left h_i(a_i) + sum_j=1^i-1 J_ij(a_ia_j)right z_i(a_1dotsa_i-1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"z_i(a_1dotsa_i-1)= sum_a=1^q exp left h_i(a) + sum_j=1^i-1 J_ij(aa_j)right ","category":"page"},{"location":"","page":"Home","title":"Home","text":"is a the normalization factor. In machine learning, this parametrization is known as soft-max regression, the generalization of logistic regression to multi-class labels.","category":"page"},{"location":"#index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ArDCA]","category":"page"},{"location":"#ArDCA.ardca-Tuple{String}","page":"Home","title":"ArDCA.ardca","text":"ardca(filename::String; kwds...)\n\nRun ardca on the fasta alignment in filename\n\nExamples\n\njulia> arnet, arvar =  ardca(\"pf14.fasta\", permorder=:ENTROPIC) ```\n\n\n\n\n\n","category":"method"},{"location":"#ArDCA.ardca-Union{Tuple{Ti}, Tuple{Array{Ti,2},Array{Float64,1}}} where Ti<:Integer","page":"Home","title":"ArDCA.ardca","text":"ardca(Z::Array{Ti,2},W::Vector{Float64}; kwds...)\n\nAuto-regressive analysis on the L×M alignment Z (numerically encoded in 1,…,21), and the M-dimensional normalized  weight vector W.\n\nReturn two struct: ::ArNet (containing the inferred hyperparameters) and ::ArVar\n\nOptional arguments:\n\nfracmax::Real=0.3 maximum fraction of insert in the sequence\nremove_dups::Bool=true if true remove duplicated sequences\ntheta=:auto if :auto compute reweighint automatically. Otherwise set a Float64 value 0 ≤ theta ≤ 1\nlambdaJ::Real=0.01 coupling L₂ regularization parameter (lagrange multiplier)\nlambdaH::Real=0.01 field L₂ regularization parameter (lagrange multiplier)\nepsconv::Real=1.0e-5 convergence value in minimzation\nmaxit::Int=1000 maximum number of iteration in minimization\nverbose::Bool=true set to false to stop printing convergence info on stdout\nmethod::Symbol=:LD_LBFGS optimization strategy see NLopt.jl for other options\npermorder::Union{Symbol,Vector{Ti}}=:ENTROPIC permutation order. Possible values are :NATURAL,:ENTROPIC,:REV_ENTROPIC,:RANDOM or a custom permutation vector\n\nExamples\n\njulia> arnet, arvar= ardca(Z,W,lambdaJ=0,lambdaH=0,permorder=:REV_ENTROPIC,epsconv=1e-12);\n\n\n\n\n\n","category":"method"},{"location":"#ArDCA.sample-Tuple{ArNet,Int64}","page":"Home","title":"ArDCA.sample","text":"sample(arnet::ArNet, msamples::Int)\n\nReturn a generated alignment in the form of a N × msamples  matrix of type ::Matrix{Int}  \n\nExamples\n\njulia> arnet,arvar=ardca(\"file.fasta\",verbose=true,permorder=:ENTROPIC, lambdaJ=0.001,lambdaH=0.001);\njulia> Zgen=Zgen=sample(arnet,1000);\n\n\n\n\n\n","category":"method"},{"location":"#ArDCA.sample_with_weights-Tuple{ArNet,Any}","page":"Home","title":"ArDCA.sample_with_weights","text":"sample_with_weights(arnet::ArNet, msamples::Int)\n\nReturn a generated alignment in the form of a N × msamples  matrix of type ::Matrix{Int} and the relative probabilities under the module\n\nExamples\n\njulia> arnet,arvar=ardca(\"file.fasta\",verbose=true,permorder=:ENTROPIC, lambdaJ=0.001,lambdaH=0.001);\njulia> Wgen,Zgen=Zgen=sample(arnet,1000);\n\n\n\n\n\n","category":"method"},{"location":"#ArDCA.softmax!-Tuple{Array{Float64,1}}","page":"Home","title":"ArDCA.softmax!","text":"softmax(x::AbstractArray{<:Real})\n\nReturn the softmax transformation applied to x\n\n\n\n\n\n","category":"method"}]
}
